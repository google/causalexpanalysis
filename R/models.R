# Copyright 2022 Google LLC

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Fit Linear Model
#'
#' Fit a linear fixed-effects model using \code{stats::lm}, a linear
#' mixed-effects model using \code{lme4::lmer}, or a survey-weighted linear
#' model using \code{survey::svyglm}.
#'
#' @param data A data frame containing variables for the linear model.
#' @param formula A formula object to pass into \code{stats::lm},
#'   \code{lmerTest::lmer}, or \code{survey::svyglm}.
#' @param random A random effect formula, or a list of random effect formulas,
#'   used only when the \code{nlme::lme} function, i.e., when
#'   \code{method = "lme"}.
#' @param correlation an optional \code{nlme::corStruct} object describing the
#'   within-group correlation structure used only for \code{nlme::gls} and
#'   \code{nlme::lme} functions, i.e., when \code{method %in% c("gls", "lme")}.
#' @param random A formula for the random effect, or a list of random effect
#'   formulas, used only when the \code{nlme::lme} function is used.
#' @param method Whether \code{"lm"} for \code{stats::lm}, \code{"svyglm"} for
#'   \code{survey::svyglm}, \code{"lmer"} for \code{lmerTest::lmer},
#'   \code{"lme"} for \code{nlme::lme}, and \code{"gls"} for \code{nlme::gls}.
#' @param weights Name of variable containing weights for use in fitting the
#'   the linear model.
#' @param design An object of class \code{svydesign}, optionally included to
#'   pass into the \code{survey::svyglm} function to fit the linear model, so
#'   we do not need to create a new \code{svydesign} object in the function
#'   call.
#' @param single_obs Whether to allow for a single observation within a
#'   random-effect level when \code{lmerTest::lmer} is run.
#' @param trim_fit Whether to apply the \code{TrimLinearModelFit} function to
#'   a \code{stats::lm} or \code{survey::svyglm} object.
#' @return A \code{stats::lm} or  \code{lmerTest::lmer} model object.

FitLinearModel <- function(data, formula, random = NULL, correlation = NULL,
                           method = c(
                             "lm", "svyglm", "lmer", "lme", "gls"
                           ), weights = NULL, design = NULL, single_obs = FALSE,
                           trim_fit = FALSE) {
  method <- match.arg(method)
  if (is.null(weights)) {
    data$weights <- 1
  } else {
    data$weights <- data[[weights]]
  }
  if (method == "lm") {
    m <- lm(formula, data = data, weights = weights)
  } else if (method == "svyglm") {
    if (is.null(design)) {
      design <- svydesign(
        ids = ~1, weights = CreateFormula(x = weights),
        data = data
      )
    }
    m <- svyglm(formula, design = design)
  } else if (method == "lmer") {
    if (single_obs) {
      control <- lmerControl(
        check.nobs.vs.nlev = "ignore",
        check.nobs.vs.nRE = "ignore"
      )
    } else {
      control <- lmerControl()
    }
    m <- lmerTest::lmer(formula, data = data, control = control)
  } else if (method == "lme") {
    m <- lme(formula, data = data, random = random, correlation = correlation)
  } else if (method == "gls") {
    m <- gls(formula, data = data, correlation = correlation)
  }
  if (method %in% c("lm", "svyglm") && trim_fit) {
    m <- TrimLinearModelFit(m)
    gc()
  }
  return(m)
}

#' Trim Linear Model Fit
#'
#' Remove model data from the linear model fit generated by \code{stats::lm},
#' \code{stats::glm}, or \code{survey::svyglm}:
#' (1) For \code{stats::lm} and \code{stats::glm}, the \code{model} object is
#'     removed.
#' (2) For \code{survey::svyglm}, the \code{model} and \code{data} objects are
#'     removed.
#'
#' @param m A model fit object generated by \code{stats::lm},
#'   \code{stats::glm}, or \code{survey::svyglm}.
#' @return A trimmed version of the model fit object.

TrimLinearModelFit <- function(m) {
  stopifnot(class(m)[1] %in% c("lm", "glm", "svyglm"))
  if (class(m)[1] %in% c("lm", "glm")) {
    m$model <- NULL
  } else if (class(m)[1] == "svyglm") {
    m$model <- NULL
    m$data <- NULL
  }
  return(m)
}

#' Extract Treatment Effect Estimate from Linear Model
#'
#' Extract the estimated absolute treatment effect from a linear model with a
#' treatment indicator variable, fitted using either
#' \code{stats::lm}, \code{lme4::lmer}, \code{lmerTest::lmer}, or
#' \code{survey::svyglm}. Compute corresponding statistics, including:
#' (1) Baseline and treatment response values, assuming that the linear model
#'     intercept gives the correct baseline value due to the appropriate
#'     centering of the covariates.
#' (2) The standard error and t statistic for the effect,
#' (3) The p-value for the significance test of the effect,
#' (4) The confidence interval (CI) for the effect, and
#' (5) The population standard deviation and standardized mean difference.
#' Optionally compute the relative effect and its CI using the Fieller or
#' delta method.
#'
#' @param m A \code{stats::lm}, \code{lme4::lmer}, \code{lmerTest::lmer}, or
#'   \code{survey::svyglm} model object.
#' @param treat Name of treatment assignment indicator variable.
#' @param hc Option for computing heteroskedasticity-corrected SEs using
#'   \code{car::hccm}. Defaults to \code{"none"}. The other values are
#'   \code{"hc0"}, \code{"hc1"}, \code{"hc2"}, \code{"hc3"}, and \code{"hc4"}.
#'   See documentation for \code{car::hccm} for details. Applies only to pure
#'   \code{stats::lm}. Doesn't apply to \code{survey::svyglm},
#'   \code{lme4::lmer}, or \code{lmerTest::lmer} objects.
#' @param conf_level Confidence level for inference.
#' @param rel_eff Whether to compute the relative effect and its CI.
#' @param reff_ci_method A string for the relative effect CI method, either
#'   \code{"fieller"} for the Fieller CI, \code{"delta"} for the delta method
#'   without log transformation of the ratio, or \code{"delta_log"} for the
#'   delta method with log transformation of the ratio. See documentation for
#'   the \code{RatioCI} function for details.
#' @param design An object of class \code{svydesign}, optionally included to
#'   pass into the \code{survey::svyvar} function to compute the survey
#'   population variance for the \code{stats::lm} model fits, if this argument
#'   is not NULL.
#' @return A single-row data frame containing the regression-adjusted absolute
#'   effect with corresponding inference statistics, and optionally, the
#'   relative effect and with its CI.

ExtractLinearModelEffect <- function(m, treat = "treat",
                                     hc = c(
                                       "none", "hc0", "hc1", "hc2", "hc3", "hc4"
                                     ), conf_level = 0.95, rel_eff = TRUE,
                                     reff_ci_method = c(
                                       "fieller", "delta", "delta_log"
                                     ), design = NULL) {
  class_m <- class(m) %>%
    intersect(c("lm", "lmerMod", "lmerModLmerTest", "svyglm"))
  stopifnot(length(class_m) > 0)
  vcov0 <- vcov(m)
  if (class(m)[1] %in% c("lmerMod", "lmerModLmerTest", "svyglm")) {
    coef_table <- summary(m)$coefficients
    out <- coef_table[treat, ]
    if (class(m)[1] %in% c("lmerMod", "lmerModLmerTest")) {
      df <- out[3]
      out <- out[-3] # Remove df entry
    } else if (class(m)[1] == "svyglm") {
      df <- m$df.residual
    }
  } else {
    hc <- match.arg(hc)
    if (hc != "none") {
      vcov0 <- hccm(m, type = hc)
    }
    df <- m$df.residual
    coef_table <- lmtest::coeftest(m, vcov. = vcov0, df = df)
    out <- lmtest::coeftest(m, vcov. = vcov0)[treat, ]
  }
  out <- t(out) %>%
    as.data.frame()
  if (inherits(m, "lmerMod")) {
    out$pval <- 2 * (1 - pnorm(abs(out[, "t value"])))
  }
  colnames(out) <- c("eff", "se", "stat", "pval")
  rownames(out) <- NULL
  t_half_alpha <- qt((1 + conf_level) / 2, df = df)
  out$lb <- with(out, eff - t_half_alpha * se)
  out$ub <- with(out, eff + t_half_alpha * se)
  # When there is a non-null survey::svydesign object (i.e., IPTW is used) and
  # the model has been fitted using stats::lm, then compute the dispersion
  # parameter using survey::svyvar. Otherwise, retrieve the usual dispersion
  # estimate using the stats::sigma function.
  if (!is.null(design) && inherits(m, "lm")) {
    out$sd <- sqrt(svyvar(resid(m), design = design)[1])
  } else {
    out$sd <- sigma(m)
  }
  out$smd <- with(out, eff / sd) # Cohen's d, since sd is pooled SD.
  out$mCa <- coef_table["(Intercept)", 1]
  out$mTa <- out$mCa + out$eff
  out <- out[c(
    "mCa", "mTa", "eff", "lb", "ub", "se", "stat", "pval", "sd", "smd"
  )]
  if (rel_eff) {
    out$reff <- out$eff / out$mCa
    index <- c(treat, "(Intercept)")
    vcov1 <- vcov0[index, index]
    # Note that since the numerator a is an effect, not the treatment response,
    # the ratio here is already a relative effect. So chg = FALSE for
    # RatioCI, so that we do not subtract 1 from the CI bounds.
    reff_ci <- RatioCI(
      method = reff_ci_method, a = out$eff, b = out$mCa, v11 = vcov1[1, 1],
      v22 = vcov1[2, 2], v12 = vcov1[1, 2], conf_level = conf_level, chg = FALSE
    )
    names(reff_ci) <- c("re_lb", "re_ub")
    out <- out %>%
      bind_cols(reff_ci)
  }
  return(out)
}

#' Extract Model Stats
#'
#' Function used \code{AdjustedEffectTable} to extract model stats using the
#' a combination of the \code{FitLinearModel} and
#' \code{ExtractLinearModelEffect} functions.
#'
#' @param data A data frame containing metrics for treatment and control
#'   subjects, an indicator variable for treatment assignment and optionally
#'   additional covariates and an integer variable for matching of pairs.
#' @param formula A formula object to pass into \code{stats::lm},
#'   \code{lmerTest::lmer}, or \code{survey::svyglm}.
#' @param model The type of regression model, whether \code{ancova} for a
#'   unconstrained ANCOVA model or \code{did} for a difference-in-differences
#'   model.
#' @param method Whether \code{"lm"} for \code{stats::lm} or \code{"lmer"} for
#'   \code{lmerTest::lmer}.
#' @param unit Name of identifier for study units, e.g., \code{obscured_gaia_id)
#'   for users in the context of Cloud experiments.
#' @param weights Name of variable containing weights for use in fitting the
#'   the linear model.
#' @param design An object of class \code{svydesign}, optionally included to
#'   pass into the \code{survey::svyglm} function to fit the linear model, so
#'   we do not need to create a new \code{svydesign} object in the function
#'   call.
#' @param single_obs Whether to allow for a single observation within a
#'   random-effect level when \code{lmerTest::lmer} is run.
#' @param treat Name of treatment assignment indicator variable.
#' @param hc Option for computing heteroskedasticity-corrected SEs using
#'   \code{car::hccm}. Defaults to \code{"none"}. The other values are
#'   \code{"hc0"}, \code{"hc1"}, \code{"hc2"}, \code{"hc3"}, and \code{"hc4"}.
#'   See documentation for \code{car::hccm} for details. Applies only to pure
#'   \code{stats::lm}. Doesn't apply to \code{survey::svyglm},
#'   \code{lme4::lmer}, or \code{lmerTest::lmer} objects.
#' @param conf_level Confidence level for inference.
#' @param rel_eff Whether to compute the relative effect and its CI.
#' @param reff_ci_method A string for the relative effect CI method, either
#'   \code{"fieller"} for the Fieller CI, \code{"delta"} for the delta method
#'   without log transformation of the ratio, or \code{"delta_log"} for the
#'   delta method with log transformation of the ratio. See documentation for
#'   the \code{RatioCI} function for details.
#' @param output_models Whether to return the regression model objects together
#'   in addition to the table of model stats. In this case, a list will be
#'   returned containing the model stats in the first entry and a list of model
#'   objects in the second entry.
#' @param trim_fit Whether to apply the \code{TrimLinearModelFit} function to
#'   a \code{stats::lm} or \code{survey::svyglm} object.
#' @return A data frame of model stats if \code{output_models = FALSE} and a
#'   list containing a data frame of model stats and a list of model objects
#'   if \code{output_models = TRUE}.

ExtractModelStats <- function(data, formula, model = c("ancova", "did"),
                              method, unit = NULL, weights = NULL,
                              design = NULL, single_obs, treat = "treat",
                              hc = c("none", "hc0", "hc1", "hc2", "hc3", "hc4"),
                              conf_level = 0.95, rel_eff = TRUE,
                              reff_ci_method = c(
                                "fieller", "delta", "delta_log"
                              ), output_models = FALSE, trim_fit = TRUE) {
  stopifnot(!is.null(unit))
  model <- match.arg(model)
  # If not done yet, remove rows with NA treatment values
  data <- data[!is.na(data[[treat]]), ]
  m <- FitLinearModel(
    data = data, formula = formula, method = method, weights = weights,
    design = design, single_obs = single_obs
  )
  effect <- ExtractLinearModelEffect(
    m = m, treat = treat, hc = hc, design = design, conf_level = conf_level,
    rel_eff = rel_eff, reff_ci_method = reff_ci_method
  )
  y <- as.character(formula[[2]]) # LHS of formula
  unitC <- data[as.logical(1 - data[[treat]]), unit]
  unitT <- data[as.logical(data[[treat]]), unit]
  # If the ANCOVA model is used, xC and xT are, respectively, the Control
  # and Treatment post-period responses. If the DID model is used, they are,
  # respectively, the Control and Treatment differences between the post- and
  # pre-period metrics.
  if (model == "ancova") {
    xC <- data[as.logical(1 - data[[treat]]), y]
    xT <- data[as.logical(data[[treat]]), y]
  } else {
    xC <- data[as.logical(1 - data[[treat]]), y[2]] -
      data[as.logical(1 - data[[treat]]), y[3]]
    xT <- data[as.logical(data[[treat]]), y[2]] -
      data[as.logical(data[[treat]]), y[3]]
  }
  row <- data.frame(
    nC = length(unique(unitC)), nT = length(unique(unitT)),
    mC = mean(xC), mT = mean(xT)
  ) %>%
    mutate(diff = mT - mC) %>%
    bind_cols(effect)
  if (output_models) {
    if (trim_fit) {
      m <- TrimLinearModelFit(m)
    }
    out <- list(stats = row, models = m)
  } else {
    out <- row
    rm(m)
  }
  gc()
  return(out)
}

#' Formulas for Linear Models to Estimate Regression-adjusted Effects
#'
#' Create a data frame with variable names and model formula for fitting
#' regression model to estimate regression-adjusted treatment effects using
#' \code{AdjustedEffectTable}.
#'
#' @param y Character vector containing names of metrics. These are names of the
#'   metrics without the \code{_post} and \code{_pre} suffixes.
#' @param vars Character vector containing the names of covariates to include
#'   in the regression model without interacting with the treatment variable.
#'   These do not need to include the pre-period values of the metrics specified
#'   in \code{y} if \code{include_pre = TRUE}.
#' @param int_vars Character vector containing the names of covariates to
#'   include in the linear model for interacting with the treatment variable.
#'   These do not need to include the pre-period values of the metrics specified
#'   in \code{y} if both \code{include_pre = TRUE} and
#'   \code{interact_pre = TRUE} hold.
#' @param treat Name of treatment assignment indicator variable.
#' @param model The type of regression model, whether \code{ancova} for a
#'   unconstrained ANCOVA model or \code{did} for a difference-in-differences
#'   model.
#' @param include_pre Whether to include pre-period metrics in the regression.
#' @param interact_pre Whether to interact pre-period metrics with the treatment
#'   variable in the regression. Applicable only when \code{include_pre = TRUE}.
#' @param paired Whether the data is paired, in which case a mixed-effects
#'   model with a random effect for the matching variable \code{match} is
#'   fitted using \code{lme4::lmer}.
#' @param var_equal Whether to assume unequal variances for the metrics across
#'   treatment and control group. Similar to the \code{var.equal} argument in
#'   the \code{stats::t.test} function. Applies only when \code{paired = FALSE}.
#' @param match Name for variable for matching paired subjects.
#' @param cluster Name of variable for clustering the data. Defaults to NULL,
#'   in which case, a linear model will be fit using \code{stats::lm}. If
#'   \code{cluster} is not NULL, or \code{paired | !var_equal}, a linear
#'   mixed-effects model will be fit using \code{lme4::lmer}.
#' @param panel_time Name of time variable for longidudinal or panel data.
#' @param unit Name of identifier for study units, e.g., \code{obscured_gaia_id)
#'   in the context of Cloud experiments.
#' @param post_suffix Suffix for the post-period metric, which will have a
#'   string name equal to \code{paste0(y, post_suffix)}. Defaults to
#'   \code{"_post"}. Pass in the empty string \code{""} to omit the suffix.
#' @return A data frame containing the variable names and model formula for
#'   fitting regression models to estimate regression-adjusted treatment
#'   effects.

AdjustedEffectFormula <- function(y, vars = NULL, int_vars = NULL,
                                  treat = "treat", model = c("ancova", "did"),
                                  include_pre = TRUE, interact_pre = TRUE,
                                  paired = FALSE, var_equal = TRUE,
                                  match = "match", cluster = NULL,
                                  panel_time = NULL, unit = NULL,
                                  post_suffix = "_post") {
  model <- match.arg(model)
  post <- paste0(y, post_suffix)
  pre <- paste0(y, "_pre")
  # Specify response according to model type, and add treatment indicator
  if (model == "did") {
    formula <- glue("{post} - {pre} ~ {treat}")
  } else {
    formula <- glue("{post} ~ {treat}")
    if (include_pre) {
      formula <- glue("{formula} + {pre}")
      if (interact_pre) {
        formula <- glue("{formula} + {treat}:{pre}")
      }
    }
  }
  # Add random effect term for matching variable for paired data, or
  # random effect term for treatment variable for unequal-variance option
  if (paired) {
    formula <- glue("{formula} + (1 | {match})")
  }
  if (!var_equal) {
    formula <- glue("{formula} + ({treat} - 1 | {unit})")
  }
  if (!is.null(cluster)) {
    formula <- glue("{formula} + (1 | {cluster})")
  }
  if (!is.null(panel_time)) {
    formula <- glue("{formula} + ({panel_time} | {unit})")
  }
  # Add covariate terms not interacted with treatment
  vars <- union(vars, panel_time)
  if (!is.null(vars)) {
    vars_sum <- sapply(
      seq_along(y),
      function(.) {
        if (include_pre) {
          formula_vars <- setdiff(vars, pre[.])
        } else {
          formula_vars <- vars
        }
        return(paste(formula_vars, collapse = " + "))
      }
    )
    formula <- paste(
      formula, ifelse(nzchar(vars_sum), paste("+", vars_sum), "")
    )
  }
  # Add covariate terms interacted with treatment
  if (!is.null(int_vars)) {
    int_vars_sum <- sapply(
      seq_along(y),
      function(.) {
        if (include_pre) {
          formula_vars <- setdiff(int_vars, pre[.])
        } else {
          formula_vars <- int_vars
        }
        return(paste(paste0(treat, ":", formula_vars), collapse = " + "))
      }
    )
    formula <- paste(
      formula, ifelse(nzchar(vars_sum), paste("+", int_vars_sum), "")
    )
  }
  # Return formulas as a named list
  names(formula) <- y
  formula <- sapply(formula, as.formula)
  return(formula)
}

#' Fit Causal Models
#'
#' A wrappper function to fit multiple causal models to estimate average
#' treatment effects, using one of the following functions:
#' (1) \code{grf::causal_forest} to fit a causal forest using the generalized
#'     random forests framework of Athey et al. (2019).
#' (2) \code{bartCause::bartc} to fit a causal Bayesian Additive Regression
#'     Tree (BART).
#' (3) \code{tmle::tmle} to fit a causal model using targeted minimum loss-based
#'     estimation (TMLE) method of van der Laan and Rubin (2006).
#' (4) \code{hdm::rlassoATE} to fit a "rigorous" lasso model described in
#'     Chernozhukov et al. (2016).
#'
#' @param data A data frame containing variables for the model.
#' @param y A vector of names of response variables.
#' @param treat The name of the treatment variable.
#' @param vars A vector of names of covariates.
#' @param center Whether to center the covariates at the sample mean.
#' @param method Method for the model, either \code{"causal_forest"},
#'   \code{"bartc"}, \code{"tmle"}, or \code{"rlasso"} for, respectively, the
#'   four models listed above.
#' @param verbose Whether to print messages and elapsed compute times.
#' @return A list of model objects returned by one of the four models described
#'   above.
#' \itemize{
#' \item Athey, Susan, Julie Tibshirani, and Stefan Wager (2019). "Generalized
#'   Random Forests." \emph{Annals of Statistics}, 47(2): 1148-1178.
#' \item van der Laan, Mark J. and Daniel Robun (2006). "Targeted Maximum
#'   Likelihood Learning." \emph{The International Journal of Biostatistics},
#'   2(1).
#' \item Chernozhukov, Victor, Chris Hansen, and Martin Spindler (2016). "hdm:
#'   High-dimensional Metrics." \emph{The R Journal}, 8(2): 185-199.
#' }

FitCausalModels <- function(data, y, treat, vars, center = FALSE,
                            method = c(
                              "causal_forest", "bartc", "tmle", "rlasso"
                            ), verbose = TRUE, ...) {
  method <- match.arg(method)
  covariate_data <- CovariateData(
    data = data, vars = vars, center = center, as_matrix = TRUE
  )
  out <- list()
  for (metric in y) {
    if (verbose) {
      cat("Using the", method, "method...\n")
      cat("Fitting model for ", metric, "...\n", sep = "")
    }
    system_time <- system.time({
      if (method == "causal_forest") {
        out[[metric]] <- grf::causal_forest(
          Y = data[[metric]], W = data[[treat]], X = covariate_data, ...
        )
      } else if (method == "bartc") {
        out[[metric]] <- bartCause::bartc(
          response = data[[metric]], treatment = data[[treat]],
          confounders = covariate_data, ...
        )
      } else if (method == "tmle") {
        out[[metric]] <- tmle::tmle(
          Y = data[[metric]], A = data[[treat]], W = covariate_data, ...
        )
      } else if (method == "rlasso") {
        out[[metric]] <- hdm::rlassoATE(
          y = data[[metric]], d = data[[treat]], x = covariate_data, ...
        )
      }
    })
    if (verbose) {
      print(system_time)
    }
  }
  return(out)
}
